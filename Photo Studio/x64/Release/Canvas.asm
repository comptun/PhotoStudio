; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31332.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@MALGKGOF@Background@			; `string'
PUBLIC	??_C@_0L@NLBOBKBC@Test?5layer@			; `string'
PUBLIC	??_C@_04EEOGCCFB@?4png@				; `string'
PUBLIC	??_C@_07OGIHEKIC@Images?1@			; `string'
PUBLIC	?m_CanvasScale@CanvasData@@2MA			; CanvasData::m_CanvasScale
PUBLIC	?m_ActiveCanvas@CanvasData@@2HA			; CanvasData::m_ActiveCanvas
PUBLIC	?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A ; CanvasData::m_CanvasOffset
PUBLIC	?m_CanvasMultiplier@CanvasData@@2MA		; CanvasData::m_CanvasMultiplier
PUBLIC	?m_CanvasHovered@CanvasData@@2_NA		; CanvasData::m_CanvasHovered
PUBLIC	?m_CanvasFocused@CanvasData@@2_NA		; CanvasData::m_CanvasFocused
PUBLIC	?m_ViewportSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A ; CanvasData::m_ViewportSize
EXTRN	__imp_IMG_SavePNG:PROC
EXTRN	__imp_SDL_FreeSurface:PROC
EXTRN	__imp_SDL_GetGlobalMouseState:PROC
EXTRN	__imp_SDL_CreateRGBSurfaceWithFormatFrom:PROC
EXTRN	__imp_SDL_GetError:PROC
;	COMDAT ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A
_BSS	SEGMENT
?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A DQ 01H DUP (?) ; CanvasData::m_CanvasOffset
_BSS	ENDS
;	COMDAT ?m_CanvasHovered@CanvasData@@2_NA
_BSS	SEGMENT
?m_CanvasHovered@CanvasData@@2_NA DB 01H DUP (?)	; CanvasData::m_CanvasHovered
_BSS	ENDS
;	COMDAT ?m_CanvasFocused@CanvasData@@2_NA
_BSS	SEGMENT
?m_CanvasFocused@CanvasData@@2_NA DB 01H DUP (?)	; CanvasData::m_CanvasFocused
_BSS	ENDS
;	COMDAT ?m_ViewportSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A
_BSS	SEGMENT
?m_ViewportSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A DQ 01H DUP (?) ; CanvasData::m_ViewportSize
_BSS	ENDS
;	COMDAT ?m_CanvasMultiplier@CanvasData@@2MA
_DATA	SEGMENT
?m_CanvasMultiplier@CanvasData@@2MA DD 03f800000r ; 1	; CanvasData::m_CanvasMultiplier
_DATA	ENDS
;	COMDAT ?m_ActiveCanvas@CanvasData@@2HA
_DATA	SEGMENT
?m_ActiveCanvas@CanvasData@@2HA DD 0ffffff9cH		; CanvasData::m_ActiveCanvas
_DATA	ENDS
;	COMDAT ?m_CanvasScale@CanvasData@@2MA
_DATA	SEGMENT
?m_CanvasScale@CanvasData@@2MA DD 03f800000r	; 1	; CanvasData::m_CanvasScale
_DATA	ENDS
;	COMDAT ??_C@_07OGIHEKIC@Images?1@
CONST	SEGMENT
??_C@_07OGIHEKIC@Images?1@ DB 'Images/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EEOGCCFB@?4png@
CONST	SEGMENT
??_C@_04EEOGCCFB@?4png@ DB '.png', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLBOBKBC@Test?5layer@
CONST	SEGMENT
??_C@_0L@NLBOBKBC@Test?5layer@ DB 'Test layer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MALGKGOF@Background@
CONST	SEGMENT
??_C@_0L@MALGKGOF@Background@ DB 'Background', 00H	; `string'
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?KM$0A@@glm@@YA?AU?$vec@$02M$0A@@0@AEBU10@0@Z ; glm::operator/<float,0>
PUBLIC	??$?DM$0A@@glm@@YA?AU?$vec@$02M$0A@@0@AEBU10@M@Z ; glm::operator*<float,0>
PUBLIC	??0?$vec@$01H$0A@@glm@@QEAA@HH@Z		; glm::vec<2,int,0>::vec<2,int,0>
PUBLIC	?SaveAs@Canvas@@QEAAXXZ				; Canvas::SaveAs
PUBLIC	?MouseInCanvas@Canvas@@QEAA_NXZ			; Canvas::MouseInCanvas
PUBLIC	?GetCanvasMousePosition@Canvas@@QEAA?AU?$vec@$02M$0A@@glm@@XZ ; Canvas::GetCanvasMousePosition
PUBLIC	?DrawCanvas@Canvas@@QEAAXXZ			; Canvas::DrawCanvas
PUBLIC	?SetActive@Canvas@@QEAAXXZ			; Canvas::SetActive
PUBLIC	??1Canvas@@QEAA@XZ				; Canvas::~Canvas
PUBLIC	??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z ; Canvas::Canvas
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN220@operator
	DD	imagerel $LN220@operator+96
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SaveAs@Canvas@@QEAAXXZ DD imagerel $LN315@SaveAs
	DD	imagerel $LN315@SaveAs+513
	DD	imagerel $unwind$?SaveAs@Canvas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MouseInCanvas@Canvas@@QEAA_NXZ DD imagerel $LN23@MouseInCan
	DD	imagerel $LN23@MouseInCan+237
	DD	imagerel $unwind$?MouseInCanvas@Canvas@@QEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCanvasMousePosition@Canvas@@QEAA?AU?$vec@$02M$0A@@glm@@XZ DD imagerel $LN26@GetCanvasM
	DD	imagerel $LN26@GetCanvasM+378
	DD	imagerel $unwind$?GetCanvasMousePosition@Canvas@@QEAA?AU?$vec@$02M$0A@@glm@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawCanvas@Canvas@@QEAAXXZ DD imagerel $LN2220
	DD	imagerel $LN2220+5791
	DD	imagerel $unwind$?DrawCanvas@Canvas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetActive@Canvas@@QEAAXXZ DD imagerel $LN41@SetActive
	DD	imagerel $LN41@SetActive+243
	DD	imagerel $unwind$?SetActive@Canvas@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Canvas@@QEAA@XZ DD imagerel $LN45@Canvas
	DD	imagerel $LN45@Canvas+169
	DD	imagerel $unwind$??1Canvas@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z DD imagerel $LN304@Canvas
	DD	imagerel $LN304@Canvas+813
	DD	imagerel $unwind$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z DQ 00828062604026d12r ; 2.27373e-269
	DQ	0420a400c057d0a2cr		; 1.4093e+10
	DD	02c0a400cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z DW 0c0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DW	034d0H
	DD	imagerel ??1LayerManager@@QEAA@XZ
	DW	036c0H
	DD	imagerel ?dtor$2@?0???0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z@4HA
	DB	02eH
	DD	imagerel __std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z DB 028H
	DD	imagerel $stateUnwindMap$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z
	DD	imagerel $ip2state$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z DQ 000087822000d3119r ; 1.1778e-308
	DQ	0001401180009681dr		; 2.78194e-308
	DQ	0700bc00de00ff011r		; 5.38534e+231
	DQ	0000030085009600ar		; 2.60927e-310
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0Canvas@@QEAA@AEAVTools@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$vec@$01M$0A@@glm@@H@Z
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Canvas@@QEAA@XZ DQ 03002320600020601r ; 1.96423e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetActive@Canvas@@QEAAXXZ DQ 00000681d00031d01r ; 5.65576e-310
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?DrawCanvas@Canvas@@QEAAXXZ DB '6'
	DB	0c9H, 04H
	DB	00H
	DB	'U', 014H
	DB	02H
	DB	'Z'
	DB	00H
	DB	' '
	DB	04H
	DB	'0'
	DB	00H
	DB	099H, 03H
	DB	06H
	DB	'D'
	DB	00H
	DB	'E', 05H
	DB	08H
	DB	'L'
	DB	00H
	DB	0f6H
	DB	0aH
	DB	'd'
	DB	00H
	DB	0c5H, 05H
	DB	02H
	DB	'Z'
	DB	00H
	DB	' '
	DB	0cH
	DB	'0'
	DB	00H
	DB	099H, 03H
	DB	0eH
	DB	'D'
	DB	00H
	DB	0b9H, 03H
	DB	010H
	DB	'F'
	DB	00H
	DB	0e5H, 06H
	DB	02H
	DB	'Z'
	DB	00H
	DB	' '
	DB	012H
	DB	'0'
	DB	00H
	DB	099H, 03H
	DB	014H
	DB	'D'
	DB	00H
	DB	'Q', 04H
	DB	016H
	DB	'@'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?DrawCanvas@Canvas@@QEAAXXZ DB 016H
	DB	0eH
	DD	imagerel __imp___std_terminate
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	08H
	DB	06aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	08H
	DB	0a2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	09H
	DB	0daH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	015H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	09H
	DB	095H
	DB	02H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	0aH
	DB	015H
	DB	03H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	095H
	DB	03H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	0aH
	DB	015H
	DB	04H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	0bH
	DB	095H
	DB	04H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?DrawCanvas@Canvas@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?DrawCanvas@Canvas@@QEAAXXZ
	DD	imagerel $ip2state$?DrawCanvas@Canvas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawCanvas@Canvas@@QEAAXXZ DD 0217619H
	DD	06ef865H
	DD	06fe85dH
	DD	070d855H
	DD	071c84dH
	DD	072b845H
	DD	073a83dH
	DD	0749838H
	DD	0758833H
	DD	076782eH
	DD	077682aH
	DD	0f97426H
	DD	0f86426H
	DD	0f73426H
	DD	0f00126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?DrawCanvas@Canvas@@QEAAXXZ
	DD	06d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCanvasMousePosition@Canvas@@QEAA?AU?$vec@$02M$0A@@glm@@XZ DQ 000049823000c3219r ; 6.38914e-309
	DQ	0000678170005881dr		; 8.99639e-309
	DQ	00012340d00076812r		; 2.53148e-308
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MouseInCanvas@Canvas@@QEAA_NXZ DQ 00003981a00092919r ; 4.99828e-309
	DQ	00005780e00048814r		; 7.60553e-309
	DQ	00000e20400066809r		; 1.22779e-309
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SaveAs@Canvas@@QEAAXXZ DQ 0047402ac00022908r ; 3.28534e-287
	DW	030dH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SaveAs@Canvas@@QEAAXXZ DW 0a06H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DW	03690H
	DD	imagerel __std_terminate
	DB	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?SaveAs@Canvas@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?SaveAs@Canvas@@QEAAXXZ
	DD	imagerel $ip2state$?SaveAs@Canvas@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SaveAs@Canvas@@QEAAXXZ DQ 00017641700092919r ; 3.25292e-308
	DQ	00015341700165417r		; 2.94871e-308
	DQ	00000701000120117r		; 6.08758e-310
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?SaveAs@Canvas@@QEAAXXZ
	DD	08aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DW 04a02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DW 0e04H
	DD	imagerel __std_terminate
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DQ 0000a340a00040a11r ; 1.41894e-308
	DD	07006520aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
; Function compile flags: /Ogtpy
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_internal.h
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_internal.h
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_draw.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_draw.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\ext\matrix_clip_space.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\ext\matrix_clip_space.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\ext\matrix_clip_space.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\LayerManager.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\Eraser.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\memory
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\compute_vector_relational.hpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp
;	COMDAT ?DrawCanvas@Canvas@@QEAAXXZ
_TEXT	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?DrawCanvas@Canvas@@QEAAXXZ PROC			; Canvas::DrawCanvas, COMDAT

; 62   : {

$LN2220:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1704]
	sub	rsp, 1920				; 00000780H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	movaps	XMMWORD PTR [rax-152], xmm12
	movaps	XMMWORD PTR [rax-168], xmm13
	movaps	XMMWORD PTR [rax-184], xmm14
	movaps	XMMWORD PTR [rax-200], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	rsi, rcx
	xorps	xmm0, xmm0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 2429 :     ImGuiWindowClass() { memset(this, 0, sizeof(*this)); ParentViewportId = (ImGuiID)-1; DockingAllowUnclassed = true; }

	movups	XMMWORD PTR window_class$[rbp-256], xmm0
	movups	XMMWORD PTR window_class$[rbp-240], xmm0
	mov	DWORD PTR window_class$[rbp-252], -1	; ffffffffH
	mov	BYTE PTR window_class$[rbp-227], 1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 66   :     window_class.DockNodeFlagsOverrideSet = ImGuiDockNodeFlags_NoCloseButton | ImGuiDockNodeFlags_NoWindowMenuButton;

	mov	DWORD PTR window_class$[rbp-232], 49152	; 0000c000H
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8380 :     ImGuiContext& g = *GImGui;

	mov	rbx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 8381 :     IM_ASSERT((window_class->ViewportFlagsOverrideSet & window_class->ViewportFlagsOverrideClear) == 0); // Cannot set both set and clear for the same bit
; 8382 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasWindowClass;

	mov	eax, DWORD PTR [rbx+19264]
	bts	eax, 11
	mov	DWORD PTR [rbx+19264], eax

; 8383 :     g.NextWindowData.WindowClass = *window_class;

	movups	xmm0, XMMWORD PTR window_class$[rbp-256]
	movups	XMMWORD PTR [rbx+19380], xmm0
	movups	xmm1, XMMWORD PTR window_class$[rbp-240]
	movups	XMMWORD PTR [rbx+19396], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 69   :     if (m_InitialDraw) {

	cmp	BYTE PTR [rcx+350], 0
	je	SHORT $LN5@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8373 :     g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasDock;

	bts	eax, 10
	mov	DWORD PTR [rbx+19264], eax

; 8374 :     g.NextWindowData.DockCond = cond ? cond : ImGuiCond_Always;

	mov	DWORD PTR [rbx+19280], 1

; 8375 :     g.NextWindowData.DockId = id;

	mov	DWORD PTR [rbx+19376], 4
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 71   :         m_InitialDraw = false;

	mov	BYTE PTR [rcx+350], 0
$LN5@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 3236 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rcx, QWORD PTR [rbx+19448]
	movss	xmm1, DWORD PTR [rbx+14848]
	movss	xmm0, DWORD PTR [rbx+14852]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_internal.h

; 1016 :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	DWORD PTR $T2[rbp-256], 2
	movss	DWORD PTR $T2[rbp-252], xmm1
	movss	DWORD PTR $T2[rbp-248], xmm0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 3236 :         g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));

	lea	rdx, QWORD PTR $T2[rbp-256]
	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QEAAXAEBUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back

; 3237 :         *pvar = val;

	xor	r12d, r12d
	mov	QWORD PTR [rbx+14848], r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 3912 :         return _Mypair._Myval2._Myptr();

	lea	rcx, QWORD PTR [rsi+248]

; 2324 :         if (_Large_string_engaged()) {

	cmp	QWORD PTR [rcx+24], 16
	jb	SHORT $LN1520@DrawCanvas

; 2325 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [rcx]
$LN1520@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 74   :     ImGui::Begin(m_CanvasName.c_str(), &m_Open);

	lea	rdx, QWORD PTR [rsi+349]
	xor	r8d, r8d
	call	?Begin@ImGui@@YA_NPEBDPEA_NH@Z		; ImGui::Begin

; 75   :     ImGui::PopStyleVar();

	mov	ecx, 1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8141 :     ImGuiWindow* window = g.CurrentWindow;

	mov	rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rax, QWORD PTR [rcx+16704]

; 8142 :     return window->Pos;

	movss	xmm8, DWORD PTR [rax+88]
	movss	xmm9, DWORD PTR [rax+92]

; 10929:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	cmp	QWORD PTR [rax+488], r12
	jne	SHORT $LN1538@DrawCanvas
	cmp	QWORD PTR [rcx+20480], r12
	mov	ecx, 656				; 00000290H
	je	SHORT $LN1539@DrawCanvas
$LN1538@DrawCanvas:
	mov	ecx, 608				; 00000260H
$LN1539@DrawCanvas:
	movss	xmm7, DWORD PTR [rax+rcx]
	movss	xmm6, DWORD PTR [rax+rcx+4]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 2632 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm6, DWORD PTR [rax+324]
	subss	xmm7, DWORD PTR [rax+320]
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 254  :     SDL_GetGlobalMouseState(&xpos, &ypos);

	lea	rdx, QWORD PTR ypos$317[rbp-256]
	lea	rcx, QWORD PTR xpos$318[rbp-256]
	call	QWORD PTR __imp_SDL_GetGlobalMouseState
	movd	xmm0, DWORD PTR ypos$317[rbp-256]

; 255  :     glm::vec2 diff = { xpos - winpos.x, ypos - winpos.y };

	cvtdq2ps xmm0, xmm0
	subss	xmm0, xmm9
	movd	xmm1, DWORD PTR xpos$318[rbp-256]
	cvtdq2ps xmm1, xmm1
	subss	xmm1, xmm8
	xorps	xmm9, xmm9
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 38   : 		: x(_x), y(_y)

	comiss	xmm9, xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 257  :     if (diff.x < 0 || diff.y < 0) {

	ja	SHORT $LN1528@DrawCanvas
	comiss	xmm9, xmm0
	ja	SHORT $LN1528@DrawCanvas

; 258  :         return false;
; 259  :     }
; 260  :     else if (diff.x > winsize.x || diff.y > winsize.y) {

	comiss	xmm1, xmm7
	ja	SHORT $LN1528@DrawCanvas
	comiss	xmm0, xmm6
	ja	SHORT $LN1528@DrawCanvas

; 261  :         return false;
; 262  :     }
; 263  : 
; 264  :     return true;

	mov	al, 1
	jmp	SHORT $LN1525@DrawCanvas
$LN1528@DrawCanvas:

; 76   : 
; 77   :     Input::Mouse::m_MouseInCanvas = MouseInCanvas();

	xor	al, al
$LN1525@DrawCanvas:
	mov	BYTE PTR ?m_MouseInCanvas@Mouse@Input@@2_NA, al ; Input::Mouse::m_MouseInCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 10935:     ImGuiWindow* window = GImGui->CurrentWindow;

	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rbx, QWORD PTR [r10+16704]

; 10929:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	mov	rcx, QWORD PTR [rbx+488]
	test	rcx, rcx
	jne	SHORT $LN2201@DrawCanvas
	cmp	QWORD PTR [r10+20480], r12
	jne	SHORT $LN2201@DrawCanvas
	movss	xmm6, DWORD PTR [rbx+656]
	subss	xmm6, DWORD PTR [rbx+320]
	mov	eax, 660				; 00000294H
	jmp	SHORT $LN1561@DrawCanvas
$LN2201@DrawCanvas:
	movss	xmm6, DWORD PTR [rbx+608]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 2632 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm6, DWORD PTR [rbx+320]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 10929:     ImVec2 mx = (window->DC.CurrentColumns || g.CurrentTable) ? window->WorkRect.Max : window->ContentRegionRect.Max;

	test	rcx, rcx
	jne	SHORT $LN1560@DrawCanvas
	cmp	QWORD PTR [r10+20480], r12
	jne	SHORT $LN1560@DrawCanvas
	mov	eax, 660				; 00000294H
	jmp	SHORT $LN1561@DrawCanvas
$LN1560@DrawCanvas:
	mov	eax, 612				; 00000264H
$LN1561@DrawCanvas:
	movss	xmm8, DWORD PTR [rax+rbx]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 2632 : static inline ImVec2  operator-(const ImVec2& lhs, const ImVec2& rhs)   { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

	subss	xmm8, DWORD PTR [rbx+324]
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 82   :     if (!CanvasData::m_CanvasHovered)

	cmp	BYTE PTR ?m_CanvasHovered@CanvasData@@2_NA, r12b ; CanvasData::m_CanvasHovered
	jne	SHORT $LN2202@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8042 :     ImGuiWindow* ref_window = g.HoveredWindow;

	mov	rcx, QWORD PTR [r10+16712]

; 8043 :     ImGuiWindow* cur_window = g.CurrentWindow;
; 8044 :     if (ref_window == NULL)

	test	rcx, rcx
	jne	SHORT $LN1655@DrawCanvas

; 8045 :         return false;

	xor	al, al
	jmp	SHORT $LN1654@DrawCanvas
$LN1655@DrawCanvas:

; 8046 : 
; 8047 :     if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
; 8048 :     {
; 8049 :         IM_ASSERT(cur_window); // Not inside a Begin()/End()
; 8050 :         const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
; 8051 :         const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
; 8052 :         if (flags & ImGuiHoveredFlags_RootWindow)
; 8053 :             cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
; 8054 : 
; 8055 :         bool result;
; 8056 :         if (flags & ImGuiHoveredFlags_ChildWindows)
; 8057 :             result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
; 8058 :         else
; 8059 :             result = (ref_window == cur_window);
; 8060 :         if (!result)

	cmp	rcx, rbx
	je	SHORT $LN1660@DrawCanvas

; 8061 :             return false;

	xor	al, al
	jmp	SHORT $LN1654@DrawCanvas
$LN1660@DrawCanvas:

; 8062 :     }
; 8063 : 
; 8064 :     if (!IsWindowContentHoverable(ref_window, flags))

	xor	edx, edx
	call	?IsWindowContentHoverable@ImGui@@YA_NPEAUImGuiWindow@@H@Z ; ImGui::IsWindowContentHoverable
	test	al, al
	je	SHORT $LN1654@DrawCanvas

; 8065 :         return false;
; 8066 :     if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
; 8067 :         if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)

	mov	eax, DWORD PTR [r10+16804]
	test	eax, eax
	je	SHORT $LN1663@DrawCanvas
	cmp	BYTE PTR [r10+16817], dl
	jne	SHORT $LN1663@DrawCanvas
	cmp	eax, DWORD PTR [rcx+180]
	je	SHORT $LN1663@DrawCanvas

; 8068 :             return false;

	xor	al, al
	jmp	SHORT $LN1654@DrawCanvas
$LN1663@DrawCanvas:

; 8069 : 
; 8070 :     // When changing hovered window we requires a bit of stationary delay before activating hover timer.
; 8071 :     // FIXME: We don't support delay other than stationary one for now, other delay would need a way
; 8072 :     // to fullfill the possibility that multiple IsWindowHovered() with varying flag could return true
; 8073 :     // for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
; 8074 :     // We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
; 8075 :     if (flags & ImGuiHoveredFlags_ForTooltip)
; 8076 :         flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
; 8077 :     if ((flags & ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window->ID)
; 8078 :         return false;
; 8079 : 
; 8080 :     return true;

	mov	al, 1
$LN1654@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 83   :         CanvasData::m_CanvasHovered = ImGui::IsWindowHovered();

	mov	BYTE PTR ?m_CanvasHovered@CanvasData@@2_NA, al ; CanvasData::m_CanvasHovered
$LN2202@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8042 :     ImGuiWindow* ref_window = g.HoveredWindow;

	mov	rcx, QWORD PTR [r10+16712]

; 8043 :     ImGuiWindow* cur_window = g.CurrentWindow;
; 8044 :     if (ref_window == NULL)

	test	rcx, rcx
	je	SHORT $LN7@DrawCanvas

; 8046 : 
; 8047 :     if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
; 8048 :     {
; 8049 :         IM_ASSERT(cur_window); // Not inside a Begin()/End()
; 8050 :         const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
; 8051 :         const bool dock_hierarchy = (flags & ImGuiHoveredFlags_DockHierarchy) != 0;
; 8052 :         if (flags & ImGuiHoveredFlags_RootWindow)
; 8053 :             cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
; 8054 : 
; 8055 :         bool result;
; 8056 :         if (flags & ImGuiHoveredFlags_ChildWindows)
; 8057 :             result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
; 8058 :         else
; 8059 :             result = (ref_window == cur_window);
; 8060 :         if (!result)

	cmp	rcx, rbx
	jne	SHORT $LN7@DrawCanvas

; 8062 :     }
; 8063 : 
; 8064 :     if (!IsWindowContentHoverable(ref_window, flags))

	xor	edx, edx
	call	?IsWindowContentHoverable@ImGui@@YA_NPEAUImGuiWindow@@H@Z ; ImGui::IsWindowContentHoverable
	test	al, al
	je	SHORT $LN7@DrawCanvas

; 8065 :         return false;
; 8066 :     if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
; 8067 :         if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)

	mov	eax, DWORD PTR [r10+16804]
	test	eax, eax
	je	SHORT $LN1575@DrawCanvas
	cmp	BYTE PTR [r10+16817], dl
	jne	SHORT $LN1575@DrawCanvas
	cmp	eax, DWORD PTR [rcx+180]
	jne	SHORT $LN7@DrawCanvas
$LN1575@DrawCanvas:

; 8276 :     FocusWindow(GImGui->CurrentWindow);

	mov	rcx, rbx
	call	?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@H@Z ; ImGui::FocusWindow
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 87   :         CanvasData::m_CanvasFocused = true;

	mov	BYTE PTR ?m_CanvasFocused@CanvasData@@2_NA, 1 ; CanvasData::m_CanvasFocused

; 88   :         SetActive();

	mov	rcx, rsi
	call	?SetActive@Canvas@@QEAAXXZ		; Canvas::SetActive
	mov	r10, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	jmp	SHORT $LN9@DrawCanvas
$LN7@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8086 :     ImGuiWindow* ref_window = g.NavWindow;

	mov	rax, QWORD PTR [r10+19712]

; 8087 :     ImGuiWindow* cur_window = g.CurrentWindow;
; 8088 : 
; 8089 :     if (ref_window == NULL)

	test	rax, rax
	je	SHORT $LN9@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 90   :     else if (ImGui::IsWindowFocused()) {

	cmp	rax, rbx
	jne	SHORT $LN9@DrawCanvas

; 91   :         CanvasData::m_CanvasFocused = true;

	mov	BYTE PTR ?m_CanvasFocused@CanvasData@@2_NA, 1 ; CanvasData::m_CanvasFocused

; 92   :         SetActive();

	mov	rcx, rsi
	call	?SetActive@Canvas@@QEAAXXZ		; Canvas::SetActive
$LN9@DrawCanvas:

; 93   :     }
; 94   : 
; 95   :     if (CanvasData::m_ActiveCanvas == m_CanvasID) {

	mov	eax, DWORD PTR [rsi+344]
	cmp	DWORD PTR ?m_ActiveCanvas@CanvasData@@2HA, eax ; CanvasData::m_ActiveCanvas
	jne	SHORT $LN10@DrawCanvas

; 96   :         SetActive();

	mov	rcx, rsi
	call	?SetActive@Canvas@@QEAAXXZ		; Canvas::SetActive
$LN10@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 10721:     ImGuiWindow* window = GetCurrentWindowRead();

	mov	rax, QWORD PTR [r10+16704]

; 10722:     return window->DC.CursorPos;

	movss	xmm2, DWORD PTR [rax+320]
	movss	xmm3, DWORD PTR [rax+324]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_internal.h

; 3237 :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [rax+245], 1
	mov	rax, QWORD PTR [r10+16704]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8389 :     return window->DrawList;

	mov	rbx, QWORD PTR [rax+736]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 279  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	mov	QWORD PTR $T20[rsp], 1065353216		; 3f800000H
	mov	DWORD PTR $T22[rsp], r12d
	mov	DWORD PTR $T22[rsp+4], 1065353216	; 3f800000H
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 101  :     ImGui::GetWindowDrawList()->AddImage(

	movaps	xmm1, xmm3
	addss	xmm1, xmm8
	movaps	xmm0, xmm2
	addss	xmm0, xmm6
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 279  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

	movss	DWORD PTR $T24[rsp], xmm0
	movss	DWORD PTR $T24[rsp+4], xmm1
	movss	DWORD PTR $T26[rsp], xmm2
	movss	DWORD PTR $T26[rsp+4], xmm3
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 101  :     ImGui::GetWindowDrawList()->AddImage(

	mov	edi, DWORD PTR [rsi+288]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_draw.cpp

; 1657 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

	mov	r14, QWORD PTR [rbx+152]

; 1658 :     if (push_texture_id)

	cmp	rdi, r14
	je	SHORT $LN120@DrawCanvas

; 1659 :         PushTextureID(user_texture_id);

	mov	edx, edi
	mov	rcx, rbx
	call	?PushTextureID@ImDrawList@@QEAAXPEAX@Z	; ImDrawList::PushTextureID
$LN120@DrawCanvas:

; 1660 : 
; 1661 :     PrimReserve(6, 4);

	mov	edx, 6
	lea	r8d, QWORD PTR [rdx-2]
	mov	rcx, rbx
	call	?PrimReserve@ImDrawList@@QEAAXHH@Z	; ImDrawList::PrimReserve

; 1662 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

	mov	DWORD PTR [rsp+40], -1			; ffffffffH
	lea	rax, QWORD PTR $T20[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR $T22[rsp]
	lea	r8, QWORD PTR $T24[rsp]
	lea	rdx, QWORD PTR $T26[rsp]
	mov	rcx, rbx
	call	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1663 : 
; 1664 :     if (push_texture_id)

	cmp	rdi, r14
	je	SHORT $LN121@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.h

; 2042 :     inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }

	movsxd	rcx, DWORD PTR [rbx+104]
	lea	eax, DWORD PTR [rcx-1]
	mov	DWORD PTR [rbx+104], eax
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui_draw.cpp

; 619  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

	test	eax, eax
	jne	SHORT $LN125@DrawCanvas
	mov	rax, r12
	jmp	SHORT $LN126@DrawCanvas
$LN125@DrawCanvas:
	mov	rax, QWORD PTR [rbx+112]
	mov	rax, QWORD PTR [rax+rcx*8-16]
$LN126@DrawCanvas:
	mov	QWORD PTR [rbx+152], rax

; 620  :     _OnChangedTextureID();

	mov	rcx, rbx
	call	?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
$LN121@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp

; 49   : 	glBindFramebuffer(GL_FRAMEBUFFER, m_FBO);

	mov	edx, DWORD PTR [rsi+280]
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 111  :         if (!(m_OldWindowSize.x == window_width && m_OldWindowSize.y == window_height)) {

	movss	xmm0, DWORD PTR [rsi+352]
	mov	r13, -9223372036854775808		; 8000000000000000H
	movss	xmm7, DWORD PTR __real@5f000000
	ucomiss	xmm0, xmm6
	jp	SHORT $LN2215@DrawCanvas
	jne	SHORT $LN2215@DrawCanvas
	movss	xmm0, DWORD PTR [rsi+356]
	ucomiss	xmm0, xmm8
	jp	SHORT $LN2215@DrawCanvas
	je	SHORT $LN11@DrawCanvas
$LN2215@DrawCanvas:

; 112  :             m_Viewport.Rescale(nullptr, window_width, window_height);

	xor	eax, eax
	movaps	xmm0, xmm8
	comiss	xmm0, xmm7
	jb	SHORT $LN2214@DrawCanvas
	subss	xmm0, xmm7
	comiss	xmm0, xmm7
	jae	SHORT $LN2214@DrawCanvas
	mov	rax, r13
$LN2214@DrawCanvas:
	cvttss2si r9, xmm0
	add	r9, rax
	xor	eax, eax
	movaps	xmm0, xmm6
	comiss	xmm0, xmm7
	jb	SHORT $LN2213@DrawCanvas
	subss	xmm0, xmm7
	comiss	xmm0, xmm7
	jae	SHORT $LN2213@DrawCanvas
	mov	rax, r13
$LN2213@DrawCanvas:
	cvttss2si r8, xmm0
	add	r8, rax
	xor	edx, edx
	lea	rcx, QWORD PTR [rsi+280]
	call	?Rescale@Framebuffer@@QEAAXPEAE_K1@Z	; Framebuffer::Rescale
$LN11@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 38   : 		: x(_x), y(_y)

	movss	DWORD PTR $T29[rbp-256], xmm6
	movss	DWORD PTR $T29[rbp-252], xmm8
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 114  :         m_OldWindowSize = glm::vec2(window_width, window_height);

	mov	rax, QWORD PTR $T29[rbp-256]
	mov	QWORD PTR [rsi+352], rax

; 115  :         glViewport(0, 0, window_width, window_height);

	cvttss2si r9d, xmm8
	cvttss2si r8d, xmm6
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR glad_glViewport

; 116  :         glClearColor(0.2f, 0.2f, 0.2f, 1.0f);

	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movaps	xmm2, xmm0
	movaps	xmm1, xmm0
	call	QWORD PTR glad_glClearColor

; 117  :         glClear(GL_COLOR_BUFFER_BIT);

	mov	ecx, 16384				; 00004000H
	call	QWORD PTR glad_glClear
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 125  :     glUseProgram(this->Program);

	mov	rax, QWORD PTR ?m_RectShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_RectShader
	mov	ecx, DWORD PTR [rax+8]
	call	QWORD PTR glad_glUseProgram
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 121  :         Primitive::m_RectShader->Uniform<glm::mat4>("model", 

	mov	rdi, QWORD PTR ?m_RectShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_RectShader
	movss	xmm2, DWORD PTR [rsi+244]
	movss	xmm11, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm2, xmm11
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 672  : 		return vec<3, T, Q>(

	movss	xmm0, DWORD PTR ?m_CanvasScale@CanvasData@@2MA ; CanvasData::m_CanvasScale
	movaps	xmm1, xmm0
	mulss	xmm1, xmm9
	mulss	xmm2, xmm0
	mulss	xmm0, DWORD PTR [rsi+240]

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T34[rbp-256], xmm0
	movss	DWORD PTR $T34[rbp-252], xmm2
	movss	DWORD PTR $T34[rbp-248], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 121  :         Primitive::m_RectShader->Uniform<glm::mat4>("model", 

	movaps	xmm15, xmm8
	mulss	xmm15, DWORD PTR __real@3f000000
	movaps	xmm1, xmm15
	subss	xmm1, DWORD PTR ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A+4
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv8401[rbp-256], xmm0
	addss	xmm0, DWORD PTR ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T35[rbp-256], xmm0
	movss	DWORD PTR $T35[rbp-252], xmm1
	mov	DWORD PTR $T35[rbp-248], r12d
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR $T37[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR $T37[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR $T37[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR $T37[rbp-208], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 121  :         Primitive::m_RectShader->Uniform<glm::mat4>("model", 

	lea	r8, QWORD PTR $T35[rbp-256]
	lea	rdx, QWORD PTR $T37[rbp-256]
	lea	rcx, QWORD PTR $T42[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	lea	r8, QWORD PTR $T34[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T43[rbp-256]
	call	??$scale@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::scale<float,0>
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T45[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T45[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T45[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T45[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05NCCFOPHA@model@
	lea	rcx, QWORD PTR $T45[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T45[rbp-256]
	mov	rcx, rdi
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	mov	r9, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T45[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN239@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T45[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN251@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN251@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN251@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN239@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 126  :         Primitive::m_RectShader->Uniform<glm::mat4>("view", glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0)));

	mov	rdi, QWORD PTR ?m_RectShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_RectShader
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T58[rbp-256], 0

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T58[rbp-248], 0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR $T60[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR $T60[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR $T60[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR $T60[rbp-208], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 126  :         Primitive::m_RectShader->Uniform<glm::mat4>("view", glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0)));

	lea	r8, QWORD PTR $T58[rbp-256]
	lea	rdx, QWORD PTR $T60[rbp-256]
	lea	rcx, QWORD PTR $T65[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T67[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T67[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T67[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T67[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04CHADEDPO@view@
	lea	rcx, QWORD PTR $T67[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T67[rbp-256]
	mov	rcx, rdi
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	mov	r9, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T67[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN356@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T67[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN368@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN368@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN368@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN356@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 127  :         Primitive::m_RectShader->Uniform<glm::mat4>("projection", glm::ortho(0.0f, (float)window_width, 0.0f, (float)window_height));

	mov	rbx, QWORD PTR ?m_RectShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_RectShader
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 179  : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T81[rbp-252], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	QWORD PTR $T81[rbp-244], 0

; 180  : 		, z(static_cast<T>(_z))

	mov	QWORD PTR $T81[rbp-232], 0

; 178  : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T81[rbp-224], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	DWORD PTR $T81[rbp-212], 0

; 180  : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T81[rbp-200], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	DWORD PTR $T81[rbp-196], 1065353216	; 3f800000H
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\ext\matrix_clip_space.inl

; 7    : 		Result[0][0] = static_cast<T>(2) / (right - left);

	movaps	xmm0, xmm6
	subss	xmm0, xmm9
	movss	xmm12, DWORD PTR __real@40000000
	movaps	xmm13, xmm12
	divss	xmm13, xmm0
	movss	DWORD PTR $T81[rbp-256], xmm13

; 8    : 		Result[1][1] = static_cast<T>(2) / (top - bottom);

	movaps	xmm1, xmm8
	subss	xmm1, xmm9
	movaps	xmm14, xmm12
	divss	xmm14, xmm1
	movss	DWORD PTR $T81[rbp-236], xmm14

; 9    : 		Result[2][2] = - static_cast<T>(1);

	mov	DWORD PTR $T81[rbp-216], -1082130432	; bf800000H

; 10   : 		Result[3][0] = - (right + left) / (right - left);

	movaps	xmm10, xmm6
	addss	xmm10, xmm9
	xorps	xmm10, xmm11
	divss	xmm10, xmm0
	movss	DWORD PTR $T81[rbp-208], xmm10

; 11   : 		Result[3][1] = - (top + bottom) / (top - bottom);

	movaps	xmm11, xmm8
	addss	xmm11, xmm9
	xorps	xmm11, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm11, xmm1
	movss	DWORD PTR $T81[rbp-204], xmm11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T97[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T97[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T97[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T97[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 10
	lea	rdx, OFFSET FLAT:??_C@_0L@PPHAJBEH@projection@
	lea	rcx, QWORD PTR $T97[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T97[rbp-256]
	mov	rcx, rbx
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	lea	r9, QWORD PTR $T81[rbp-256]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T97[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN528@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T97[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN540@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN540@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN540@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN528@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 128  :         Primitive::m_RectShader->Uniform<glm::vec4>("color", { 0.5f, 0.5f, 0.5f, 1.0f });

	mov	rbx, QWORD PTR ?m_RectShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_RectShader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T111[rsp], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T111[rsp+16], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T111[rsp+24], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T111[rsp], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05PEENBMOG@color@
	lea	rcx, QWORD PTR $T111[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 118  :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T111[rsp]
	mov	rcx, rbx
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 119  :     glUniform4f(Location, Value[0], Value[1], Value[2], Value[3]);

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [rsp+32], xmm0
	movss	xmm1, DWORD PTR __real@3f000000
	movaps	xmm3, xmm1
	movaps	xmm2, xmm1
	mov	ecx, eax
	call	QWORD PTR glad_glUniform4f
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T111[rsp+24]
	cmp	rdx, 16
	jb	SHORT $LN660@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T111[rsp]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN672@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN672@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN672@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN660@DrawCanvas:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4647 :             _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T111[rsp+16], r12

; 4648 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T111[rsp+24], 15

; 4649 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4650 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T111[rsp], 0
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 130  :         Primitive::m_CanvasObject->Draw();

	mov	rbx, QWORD PTR ?m_CanvasObject@Primitive@@2V?$unique_ptr@VCanvasObject@@U?$default_delete@VCanvasObject@@@std@@@std@@A ; Primitive::m_CanvasObject
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp

; 32   : 	glBindVertexArray(m_VAO);

	mov	ecx, DWORD PTR [rbx]
	call	QWORD PTR glad_glBindVertexArray
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1715 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+24]
	sub	rdx, QWORD PTR [rbx+16]
	sar	rdx, 2
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp

; 33   : 	glDrawElements(GL_TRIANGLES, m_Indices.size(), GL_UNSIGNED_INT, (void*)0);

	xor	r9d, r9d
	lea	ecx, QWORD PTR [r9+4]
	mov	r8d, 5125				; 00001405H
	call	QWORD PTR glad_glDrawElements

; 34   : 	glBindVertexArray(0);

	xor	ecx, ecx
	call	QWORD PTR glad_glBindVertexArray
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 125  :     glUseProgram(this->Program);

	mov	rax, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
	mov	ecx, DWORD PTR [rax+8]
	call	QWORD PTR glad_glUseProgram
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 135  :         Primitive::m_CanvasShader->Uniform<glm::mat4>("model",

	mov	rdi, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
	movss	xmm2, DWORD PTR [rsi+244]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 672  : 		return vec<3, T, Q>(

	movss	xmm0, DWORD PTR ?m_CanvasScale@CanvasData@@2MA ; CanvasData::m_CanvasScale
	movaps	xmm1, xmm0
	mulss	xmm1, xmm9
	mulss	xmm2, xmm0
	mulss	xmm0, DWORD PTR [rsi+240]

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T130[rbp-256], xmm0
	movss	DWORD PTR $T130[rbp-252], xmm2
	movss	DWORD PTR $T130[rbp-248], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 135  :         Primitive::m_CanvasShader->Uniform<glm::mat4>("model",

	subss	xmm15, DWORD PTR ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A+4
	movss	xmm0, DWORD PTR tv8401[rbp-256]
	addss	xmm0, DWORD PTR ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T131[rbp-256], xmm0
	movss	DWORD PTR $T131[rbp-252], xmm15
	mov	DWORD PTR $T131[rbp-248], 0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR $T133[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR $T133[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR $T133[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR $T133[rbp-208], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 135  :         Primitive::m_CanvasShader->Uniform<glm::mat4>("model",

	lea	r8, QWORD PTR $T131[rbp-256]
	lea	rdx, QWORD PTR $T133[rbp-256]
	lea	rcx, QWORD PTR $T138[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	lea	r8, QWORD PTR $T130[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T139[rbp-256]
	call	??$scale@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::scale<float,0>
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T141[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T141[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T141[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T141[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05NCCFOPHA@model@
	lea	rcx, QWORD PTR $T141[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T141[rbp-256]
	mov	rcx, rdi
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	mov	r9, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T141[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1491@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T141[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1503@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1503@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1503@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN1491@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 141  :         Primitive::m_CanvasShader->Uniform<glm::mat4>("view", glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0)));

	mov	rdi, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T154[rbp-256], 0

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T154[rbp-248], 0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR $T156[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR $T156[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR $T156[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR $T156[rbp-208], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 141  :         Primitive::m_CanvasShader->Uniform<glm::mat4>("view", glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0)));

	lea	r8, QWORD PTR $T154[rbp-256]
	lea	rdx, QWORD PTR $T156[rbp-256]
	lea	rcx, QWORD PTR $T161[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T163[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T163[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T163[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T163[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04CHADEDPO@view@
	lea	rcx, QWORD PTR $T163[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T163[rbp-256]
	mov	rcx, rdi
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	mov	r9, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T163[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN876@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T163[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN888@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN888@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN888@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN876@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 142  :         Primitive::m_CanvasShader->Uniform<glm::mat4>("projection", glm::ortho(0.0f, (float)window_width, 0.0f, (float)window_height));

	mov	rbx, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 179  : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T177[rbp-252], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	QWORD PTR $T177[rbp-244], 0

; 180  : 		, z(static_cast<T>(_z))

	mov	QWORD PTR $T177[rbp-232], 0

; 178  : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T177[rbp-224], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	DWORD PTR $T177[rbp-212], 0

; 180  : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T177[rbp-200], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	DWORD PTR $T177[rbp-196], 1065353216	; 3f800000H
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\ext\matrix_clip_space.inl

; 7    : 		Result[0][0] = static_cast<T>(2) / (right - left);

	movss	DWORD PTR $T177[rbp-256], xmm13

; 8    : 		Result[1][1] = static_cast<T>(2) / (top - bottom);

	movss	DWORD PTR $T177[rbp-236], xmm14

; 9    : 		Result[2][2] = - static_cast<T>(1);

	mov	DWORD PTR $T177[rbp-216], -1082130432	; bf800000H

; 10   : 		Result[3][0] = - (right + left) / (right - left);

	movss	DWORD PTR $T177[rbp-208], xmm10

; 11   : 		Result[3][1] = - (top + bottom) / (top - bottom);

	movss	DWORD PTR $T177[rbp-204], xmm11
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T193[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T193[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T193[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T193[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 10
	lea	rdx, OFFSET FLAT:??_C@_0L@PPHAJBEH@projection@
	lea	rcx, QWORD PTR $T193[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T193[rbp-256]
	mov	rcx, rbx
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	lea	r9, QWORD PTR $T177[rbp-256]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T193[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1048@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T193[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1060@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1060@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1060@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN1048@DrawCanvas:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4647 :             _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T193[rbp-240], r12

; 4648 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T193[rbp-232], 15

; 4649 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4650 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T193[rbp-256], 0
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 144  :         glBindTexture(GL_TEXTURE_2D, m_DrawBuffer.GetTexture());

	mov	edx, DWORD PTR [rsi+320]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR glad_glBindTexture

; 145  :         Primitive::m_CanvasObject->Draw();

	mov	rbx, QWORD PTR ?m_CanvasObject@Primitive@@2V?$unique_ptr@VCanvasObject@@U?$default_delete@VCanvasObject@@@std@@@std@@A ; Primitive::m_CanvasObject
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp

; 32   : 	glBindVertexArray(m_VAO);

	mov	ecx, DWORD PTR [rbx]
	call	QWORD PTR glad_glBindVertexArray
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1715 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+24]
	sub	rdx, QWORD PTR [rbx+16]
	sar	rdx, 2
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp

; 33   : 	glDrawElements(GL_TRIANGLES, m_Indices.size(), GL_UNSIGNED_INT, (void*)0);

	xor	r9d, r9d
	lea	ecx, QWORD PTR [r9+4]
	mov	r8d, 5125				; 00001405H
	call	QWORD PTR glad_glDrawElements

; 34   : 	glBindVertexArray(0);

	xor	ecx, ecx
	call	QWORD PTR glad_glBindVertexArray
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp

; 53   : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	xor	edx, edx
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 154  :     glViewport(0, 0, CanvasData::m_CanvasSize.x, CanvasData::m_CanvasSize.y);

	cvttss2si r9d, DWORD PTR ?m_CanvasSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A+4
	cvttss2si r8d, DWORD PTR ?m_CanvasSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR glad_glViewport
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp

; 49   : 	glBindFramebuffer(GL_FRAMEBUFFER, m_FBO);

	mov	edx, DWORD PTR [rsi+312]
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
	xorps	xmm3, xmm3
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 157  :     glClearColor(1, 1, 1, 0);

	movss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm2, xmm0
	movaps	xmm1, xmm0
	call	QWORD PTR glad_glClearColor

; 158  :     glClear(GL_COLOR_BUFFER_BIT);

	mov	ecx, 16384				; 00004000H
	call	QWORD PTR glad_glClear
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 125  :     glUseProgram(this->Program);

	mov	rax, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
	mov	ecx, DWORD PTR [rax+8]
	call	QWORD PTR glad_glUseProgram
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 161  :     Primitive::m_CanvasShader->Uniform<glm::mat4>("model",

	mov	rdi, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
	movss	xmm1, DWORD PTR [rsi+244]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	movss	xmm0, DWORD PTR [rsi+240]
	movss	DWORD PTR $T207[rbp-256], xmm0

; 55   : 		, y(static_cast<T>(_y))

	movss	DWORD PTR $T207[rbp-252], xmm1

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T207[rbp-248], 0
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 161  :     Primitive::m_CanvasShader->Uniform<glm::mat4>("model",

	movss	xmm10, DWORD PTR __real@3f000000
	mulss	xmm1, xmm10
	mulss	xmm0, xmm10
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	DWORD PTR $T208[rbp-256], xmm0
	movss	DWORD PTR $T208[rbp-252], xmm1
	mov	DWORD PTR $T208[rbp-248], 0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR $T210[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR $T210[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR $T210[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR $T210[rbp-208], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 161  :     Primitive::m_CanvasShader->Uniform<glm::mat4>("model",

	lea	r8, QWORD PTR $T208[rbp-256]
	lea	rdx, QWORD PTR $T210[rbp-256]
	lea	rcx, QWORD PTR $T215[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	lea	r8, QWORD PTR $T207[rbp-256]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T216[rbp-256]
	call	??$scale@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::scale<float,0>
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T218[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T218[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T218[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T218[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 5
	lea	rdx, OFFSET FLAT:??_C@_05NCCFOPHA@model@
	lea	rcx, QWORD PTR $T218[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T218[rbp-256]
	mov	rcx, rdi
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	mov	r9, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T218[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1177@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T218[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1189@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1189@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1189@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN1177@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 167  :     Primitive::m_CanvasShader->Uniform<glm::mat4>("view", glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0)));

	mov	rdi, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 54   : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T231[rbp-256], 0

; 56   : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T231[rbp-248], 0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 178  : 		: x(static_cast<T>(_x))

	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movaps	XMMWORD PTR $T233[rbp-256], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	XMMWORD PTR $T233[rbp-240], xmm1
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movaps	XMMWORD PTR $T233[rbp-224], xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movaps	XMMWORD PTR $T233[rbp-208], xmm1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 167  :     Primitive::m_CanvasShader->Uniform<glm::mat4>("view", glm::translate(glm::mat4(1.0f), glm::vec3(0, 0, 0)));

	lea	r8, QWORD PTR $T231[rbp-256]
	lea	rdx, QWORD PTR $T233[rbp-256]
	lea	rcx, QWORD PTR $T238[rbp-256]
	call	??$translate@M$0A@@glm@@YA?AU?$mat@$03$03M$0A@@0@AEBU10@AEBU?$vec@$02M$0A@@0@@Z ; glm::translate<float,0>
	mov	rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T240[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T240[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T240[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T240[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 4
	lea	rdx, OFFSET FLAT:??_C@_04CHADEDPO@view@
	lea	rcx, QWORD PTR $T240[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T240[rbp-256]
	mov	rcx, rdi
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	mov	r9, rbx
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T240[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1281@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T240[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1293@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1293@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1293@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN1281@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 168  :     Primitive::m_CanvasShader->Uniform<glm::mat4>("projection", glm::ortho(0.0f, m_CanvasSize.x, 0.0f, m_CanvasSize.y));

	mov	rbx, QWORD PTR ?m_CanvasShader@Primitive@@2V?$unique_ptr@VShader@@U?$default_delete@VShader@@@std@@@std@@A ; Primitive::m_CanvasShader
	movss	xmm4, DWORD PTR [rsi+244]
	movss	xmm3, DWORD PTR [rsi+240]
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec4.inl

; 179  : 		, y(static_cast<T>(_y))

	mov	QWORD PTR $T254[rbp-252], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	QWORD PTR $T254[rbp-244], 0

; 180  : 		, z(static_cast<T>(_z))

	mov	QWORD PTR $T254[rbp-232], 0

; 178  : 		: x(static_cast<T>(_x))

	mov	QWORD PTR $T254[rbp-224], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	DWORD PTR $T254[rbp-212], 0

; 180  : 		, z(static_cast<T>(_z))

	mov	DWORD PTR $T254[rbp-200], 0

; 181  : 		, w(static_cast<T>(_w))

	mov	DWORD PTR $T254[rbp-196], 1065353216	; 3f800000H
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\ext\matrix_clip_space.inl

; 7    : 		Result[0][0] = static_cast<T>(2) / (right - left);

	movaps	xmm1, xmm3
	subss	xmm1, xmm9
	movaps	xmm0, xmm12
	divss	xmm0, xmm1
	movss	DWORD PTR $T254[rbp-256], xmm0

; 8    : 		Result[1][1] = static_cast<T>(2) / (top - bottom);

	movaps	xmm2, xmm4
	subss	xmm2, xmm9
	divss	xmm12, xmm2
	movss	DWORD PTR $T254[rbp-236], xmm12

; 9    : 		Result[2][2] = - static_cast<T>(1);

	mov	DWORD PTR $T254[rbp-216], -1082130432	; bf800000H

; 10   : 		Result[3][0] = - (right + left) / (right - left);

	addss	xmm3, xmm9
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm3, xmm1
	movss	DWORD PTR $T254[rbp-208], xmm3

; 11   : 		Result[3][1] = - (top + bottom) / (top - bottom);

	addss	xmm4, xmm9
	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	divss	xmm4, xmm2
	movss	DWORD PTR $T254[rbp-204], xmm4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 2364 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR $T270[rbp-256], r12

; 4610 :         _My_data._Mysize = 0;

	mov	QWORD PTR $T270[rbp-240], r12

; 4611 : 
; 4612 : #if _HAS_CXX20
; 4613 :         if (_STD is_constant_evaluated()) {
; 4614 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4615 :             auto& _Al              = _Getal();
; 4616 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4617 :             _My_data._Bx._Ptr      = _New_ptr;
; 4618 : 
; 4619 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4620 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4621 :         } else
; 4622 : #endif // _HAS_CXX20
; 4623 :         {
; 4624 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR $T270[rbp-232], 15

; 4625 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4626 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T270[rbp-256], 0

; 3258 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 10
	lea	rdx, OFFSET FLAT:??_C@_0L@PPHAJBEH@projection@
	lea	rcx, QWORD PTR $T270[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Shader.cpp

; 94   :     unsigned int Location = this->GetUniformLocation(UniformName);

	lea	rdx, QWORD PTR $T270[rbp-256]
	mov	rcx, rbx
	call	?GetUniformLocation@Shader@@QEAAIAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Shader::GetUniformLocation

; 95   :     glUniformMatrix4fv(Location, 1, GL_FALSE, &Value[0][0]);

	lea	r9, QWORD PTR $T254[rbp-256]
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+1]
	mov	ecx, eax
	call	QWORD PTR glad_glUniformMatrix4fv
	npad	1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4632 :         if (_Mypair._Myval2._Large_string_engaged()) {

	mov	rdx, QWORD PTR $T270[rbp-232]
	cmp	rdx, 16
	jb	SHORT $LN1453@DrawCanvas

; 4633 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4634 :             auto& _Al          = _Getal();
; 4635 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4636 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T270[rbp-256]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN1465@DrawCanvas

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN1465@DrawCanvas
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN1465@DrawCanvas:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN1453@DrawCanvas:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\xstring

; 4647 :             _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T270[rbp-240], r12

; 4648 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T270[rbp-232], 15

; 4649 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4650 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T270[rbp-256], 0
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 170  :     for (int i = 0; i < m_Layers.size(); ++i) {

	mov	r14d, r12d
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1715 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rsi+80]
	mov	rax, QWORD PTR [rsi+88]
	sub	rax, rdx
	sar	rax, 4
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 170  :     for (int i = 0; i < m_Layers.size(); ++i) {

	test	rax, rax
	je	SHORT $LN3@DrawCanvas
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1714 :         auto& _My_data = _Mypair._Myval2;

	mov	rdi, r12
	npad	7
$LL4@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 171  :         if (!m_Layers[i]->m_Visible) {

	mov	rax, QWORD PTR [rdi+rdx]
	cmp	BYTE PTR [rax+32], 0
	je	SHORT $LN2@DrawCanvas

; 172  :             continue;
; 173  :         }
; 174  :         glBindTexture(GL_TEXTURE_2D, m_Layers[i]->GetTexture());

	mov	edx, DWORD PTR [rax+8]
	mov	ecx, 3553				; 00000de1H
	call	QWORD PTR glad_glBindTexture

; 175  :         Primitive::m_CanvasObject->Draw();

	mov	rbx, QWORD PTR ?m_CanvasObject@Primitive@@2V?$unique_ptr@VCanvasObject@@U?$default_delete@VCanvasObject@@@std@@@std@@A ; Primitive::m_CanvasObject
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp

; 32   : 	glBindVertexArray(m_VAO);

	mov	ecx, DWORD PTR [rbx]
	call	QWORD PTR glad_glBindVertexArray
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1715 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rbx+24]
	sub	rdx, QWORD PTR [rbx+16]
	sar	rdx, 2
; File H:\Downloads\Photo Studio\Photo Studio\Source\CanvasObject.cpp

; 33   : 	glDrawElements(GL_TRIANGLES, m_Indices.size(), GL_UNSIGNED_INT, (void*)0);

	xor	r9d, r9d
	lea	ecx, QWORD PTR [r9+4]
	mov	r8d, 5125				; 00001405H
	call	QWORD PTR glad_glDrawElements

; 34   : 	glBindVertexArray(0);

	xor	ecx, ecx
	call	QWORD PTR glad_glBindVertexArray
$LN2@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 170  :     for (int i = 0; i < m_Layers.size(); ++i) {

	inc	r14d
	add	rdi, 16
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1715 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rsi+80]
	mov	rcx, QWORD PTR [rsi+88]
	sub	rcx, rdx
	sar	rcx, 4
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 170  :     for (int i = 0; i < m_Layers.size(); ++i) {

	movsxd	rax, r14d
	cmp	rax, rcx
	jb	SHORT $LL4@DrawCanvas
$LN3@DrawCanvas:

; 176  :     }
; 177  : 
; 178  :     m_DrawPixelBuffer.Download();

	lea	rcx, QWORD PTR [rsi+176]
	call	?Download@PixelBuffer@@QEAAXXZ		; PixelBuffer::Download

; 179  : 
; 180  :     // Draw widgets
; 181  : 
; 182  :     m_Tools.DrawRectangularSelect();

	mov	rcx, QWORD PTR [rsi+104]
	add	rcx, 96					; 00000060H
	call	?DrawRectangularSelect@RectangularSelect@@QEAAXXZ ; RectangularSelect::DrawRectangularSelect
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp

; 53   : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	xor	edx, edx
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8085 :     ImGuiContext& g = *GImGui;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui

; 8086 :     ImGuiWindow* ref_window = g.NavWindow;

	mov	rcx, QWORD PTR [rax+19712]

; 8087 :     ImGuiWindow* cur_window = g.CurrentWindow;
; 8088 : 
; 8089 :     if (ref_window == NULL)

	test	rcx, rcx
	je	$LN2200@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 190  :     if (!ImGui::IsWindowFocused()) {

	cmp	rcx, QWORD PTR [rax+16704]
	jne	$LN2200@DrawCanvas

; 191  :         glUseProgram(0);
; 192  :         ImGui::End();
; 193  :         return;
; 194  :     }
; 195  : 
; 196  :     if (CanvasData::m_ActiveCanvas != m_CanvasID) {

	mov	eax, DWORD PTR [rsi+344]
	cmp	DWORD PTR ?m_ActiveCanvas@CanvasData@@2HA, eax ; CanvasData::m_ActiveCanvas
	je	SHORT $LN15@DrawCanvas

; 197  :         CanvasData::m_ActiveCanvas = m_CanvasID;

	mov	DWORD PTR ?m_ActiveCanvas@CanvasData@@2HA, eax ; CanvasData::m_ActiveCanvas

; 198  :         SetActive();

	mov	rcx, rsi
	call	?SetActive@Canvas@@QEAAXXZ		; Canvas::SetActive

; 199  :         m_Viewport.Rescale(nullptr, window_width, window_height);

	xor	edx, edx
	comiss	xmm8, xmm7
	jb	SHORT $LN2212@DrawCanvas
	subss	xmm8, xmm7
	comiss	xmm8, xmm7
	jae	SHORT $LN2212@DrawCanvas
	mov	rdx, r13
$LN2212@DrawCanvas:
	cvttss2si r9, xmm8
	add	r9, rdx
	xor	eax, eax
	comiss	xmm6, xmm7
	jb	SHORT $LN2211@DrawCanvas
	subss	xmm6, xmm7
	comiss	xmm6, xmm7
	jae	SHORT $LN2211@DrawCanvas
	mov	rax, r13
$LN2211@DrawCanvas:
	cvttss2si r8, xmm6
	add	r8, rax
	xor	edx, edx
	lea	rcx, QWORD PTR [rsi+280]
	call	?Rescale@Framebuffer@@QEAAXPEAE_K1@Z	; Framebuffer::Rescale
$LN15@DrawCanvas:

; 200  :     }
; 201  : 
; 202  : 
; 203  :     glViewport(0, 0, CanvasData::m_CanvasSize.x, CanvasData::m_CanvasSize.y);

	cvttss2si r9d, DWORD PTR ?m_CanvasSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A+4
	cvttss2si r8d, DWORD PTR ?m_CanvasSize@CanvasData@@2U?$vec@$01M$0A@@glm@@A
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR glad_glViewport
; File H:\Downloads\Photo Studio\Photo Studio\Source\LayerManager.cpp

; 46   : 	m_Layers.at(m_ActiveLayer)->Bind();

	mov	rcx, QWORD PTR [rsi+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1750 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rdx, QWORD PTR [rsi+80]
	mov	rax, QWORD PTR [rsi+88]
	sub	rax, rdx
	sar	rax, 4
	cmp	rax, rcx
	jbe	$LN2209@DrawCanvas

; 1752 :         }
; 1753 : 
; 1754 :         return _My_data._Myfirst[_Pos];

	add	rcx, rcx
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp

; 49   : 	glBindFramebuffer(GL_FRAMEBUFFER, m_FBO);

	mov	rax, QWORD PTR [rdx+rcx*8]
	mov	edx, DWORD PTR [rax]
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 206  :     m_PixelBuffer.Download();

	lea	rcx, QWORD PTR [rsi+112]
	call	?Download@PixelBuffer@@QEAAXXZ		; PixelBuffer::Download
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\imgui\imgui.cpp

; 8142 :     return window->Pos;

	mov	rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
	mov	rcx, QWORD PTR [rax+16704]
	movss	xmm6, DWORD PTR [rcx+88]
	movss	xmm8, DWORD PTR [rcx+92]

; 8184 :     return window->Size;

	movss	xmm7, DWORD PTR [rcx+96]
	movss	xmm9, DWORD PTR [rcx+100]
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 238  :     glm::vec2 mousePos = Input::Mouse::Pos;

	mov	rax, QWORD PTR ?Pos@Mouse@Input@@2U?$vec@$01M$0A@@glm@@A ; Input::Mouse::Pos
	mov	QWORD PTR mousePos$315[rsp], rax
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 38   : 		: x(_x), y(_y)

	mov	QWORD PTR WindowPos$316[rbp-256], r12
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 240  :     SDL_GetWindowPosition(SDL_GL_GetCurrentWindow(), &WindowPos.x, &WindowPos.y);

	call	QWORD PTR __imp_SDL_GL_GetCurrentWindow
	mov	rcx, rax
	lea	r8, QWORD PTR WindowPos$316[rbp-252]
	lea	rdx, QWORD PTR WindowPos$316[rbp-256]
	call	QWORD PTR __imp_SDL_GetWindowPosition
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 38   : 		: x(_x), y(_y), z(_z)

	movss	xmm2, DWORD PTR ?m_CanvasScale@CanvasData@@2MA ; CanvasData::m_CanvasScale
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 242  :         mousePos.y - CanvasData::m_CanvasOffset.y - ViewportPos.y - (ViewportSize.y - m_CanvasSize.y * CanvasData::m_CanvasScale) / 2.0f + WindowPos.y, 0.0f) / glm::vec3(CanvasData::m_CanvasScale, CanvasData::m_CanvasScale, 1.0f);

	movss	xmm1, DWORD PTR [rsi+244]
	movss	xmm3, DWORD PTR mousePos$315[rsp]
	subss	xmm3, DWORD PTR ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A
	subss	xmm3, xmm6
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rsi+240]
	subss	xmm7, xmm0
	mulss	xmm7, xmm10
	subss	xmm3, xmm7
	movd	xmm0, DWORD PTR WindowPos$316[rbp-256]
	cvtdq2ps xmm0, xmm0
	addss	xmm3, xmm0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 753  : 		return vec<3, T, Q>(

	divss	xmm3, xmm2
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 243  :     Input::Mouse::CanvasPos = FinalPos;

	movss	DWORD PTR ?CanvasPos@Mouse@Input@@2U?$vec@$02M$0A@@glm@@A, xmm3

; 242  :         mousePos.y - CanvasData::m_CanvasOffset.y - ViewportPos.y - (ViewportSize.y - m_CanvasSize.y * CanvasData::m_CanvasScale) / 2.0f + WindowPos.y, 0.0f) / glm::vec3(CanvasData::m_CanvasScale, CanvasData::m_CanvasScale, 1.0f);

	movss	xmm4, DWORD PTR mousePos$315[rsp+4]
	subss	xmm4, DWORD PTR ?m_CanvasOffset@CanvasData@@2U?$vec@$01M$0A@@glm@@A+4
	subss	xmm4, xmm8
	mulss	xmm1, xmm2
	subss	xmm9, xmm1
	mulss	xmm9, xmm10
	subss	xmm4, xmm9
	movd	xmm0, DWORD PTR WindowPos$316[rbp-252]
	cvtdq2ps xmm0, xmm0
	addss	xmm4, xmm0
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec3.inl

; 753  : 		return vec<3, T, Q>(

	divss	xmm4, xmm2
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 243  :     Input::Mouse::CanvasPos = FinalPos;

	movss	DWORD PTR ?CanvasPos@Mouse@Input@@2U?$vec@$02M$0A@@glm@@A+4, xmm4
	mov	DWORD PTR ?CanvasPos@Mouse@Input@@2U?$vec@$02M$0A@@glm@@A+8, 0

; 207  : 
; 208  :     glm::vec3 BrushPosition = GetCanvasMousePosition();
; 209  :     if (m_Tools.m_Tool == Tool::Brush)

	mov	rcx, QWORD PTR [rsi+104]
	mov	eax, DWORD PTR [rcx+112]
	cmp	eax, 2
	jne	SHORT $LN16@DrawCanvas

; 210  :     {
; 211  :         m_Tools.m_BrushMode = BrushMode::Pencil;

	mov	DWORD PTR [rcx], r12d

; 212  :         m_Tools.DrawInterpolatedPaintbrush();

	movss	xmm1, DWORD PTR __real@bf800000
	mov	rcx, QWORD PTR [rsi+104]
	call	?DrawInterpolatedPaintbrush@Brush@@QEAAXM@Z ; Brush::DrawInterpolatedPaintbrush

; 213  :     }

	jmp	$LN1712@DrawCanvas
$LN16@DrawCanvas:

; 214  :     else if (m_Tools.m_Tool == Tool::Eraser)

	cmp	eax, 4
	jne	SHORT $LN18@DrawCanvas

; 215  :     {
; 216  :         m_Tools.m_BrushMode = BrushMode::Eraser;

	mov	DWORD PTR [rcx], 1
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\Eraser.cpp

; 15   :     return m_EraserSize;

	mov	rcx, QWORD PTR [rsi+104]
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 217  :         m_Tools.DrawInterpolatedPaintbrush(m_Tools.GetEraserSize());

	movss	xmm1, DWORD PTR [rcx+92]
	call	?DrawInterpolatedPaintbrush@Brush@@QEAAXM@Z ; Brush::DrawInterpolatedPaintbrush

; 218  :     }

	jmp	$LN1712@DrawCanvas
$LN18@DrawCanvas:

; 219  :     else if (m_Tools.m_Tool == Tool::PaintBucket) {

	cmp	eax, 3
	jne	SHORT $LN20@DrawCanvas
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1735 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [rsi+40]
	shl	rcx, 4
	add	rcx, QWORD PTR [rsi+80]
	xorps	xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\memory

; 1401 :     element_type* _Ptr{nullptr};

	movdqu	XMMWORD PTR $T304[rsp], xmm0

; 1327 :         if (_Rep) {

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN1705@DrawCanvas

; 1100 :         _MT_INCR(_Uses);

	lock inc DWORD PTR [rax+8]
$LN1705@DrawCanvas:

; 1288 :         _Ptr = _Other._Ptr;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR $T304[rsp], rax

; 1289 :         _Rep = _Other._Rep;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR $T304[rsp+8], rax
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 220  :         m_Tools.FloodFill4Stack(GetActiveLayer(), m_PixelBuffer);

	lea	r8, QWORD PTR [rsi+112]
	lea	rdx, QWORD PTR $T304[rsp]
	call	?FloodFill4Stack@PaintBucket@@QEAAXV?$shared_ptr@VLayer@@@std@@AEAVPixelBuffer@@@Z ; PaintBucket::FloodFill4Stack

; 221  :     }

	jmp	$LN1712@DrawCanvas
$LN20@DrawCanvas:

; 222  :     else if (m_Tools.m_Tool == Tool::RectangularSelect) {

	cmp	eax, 8
	jne	$LN1712@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp

; 17   : 	if (Input::Mouse::Button == SDL_BUTTON_LEFT) {

	cmp	BYTE PTR ?Button@Mouse@Input@@2EA, 1	; Input::Mouse::Button
	jne	$LN1712@DrawCanvas

; 18   : 		if (Input::Mouse::State == SDL_PRESSED) {

	movzx	eax, BYTE PTR ?State@Mouse@Input@@2EA	; Input::Mouse::State
	cmp	al, 1
	jne	SHORT $LN1708@DrawCanvas

; 19   : 			if (Input::Mouse::m_InitialClick) {

	cmp	BYTE PTR ?m_InitialClick@Mouse@Input@@2_NA, 0 ; Input::Mouse::m_InitialClick
	je	SHORT $LN1710@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 90   : 		: x(static_cast<T>(v.x))

	movss	DWORD PTR $T308[rsp], xmm3

; 91   : 		, y(static_cast<T>(v.y))

	movss	DWORD PTR $T308[rsp+4], xmm4
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp

; 20   : 				m_Start = Input::Mouse::CanvasPos;

	mov	rax, QWORD PTR $T308[rsp]
	mov	QWORD PTR [rcx+96], rax

; 21   : 				m_End = m_Start;

	mov	QWORD PTR [rcx+104], rax
	movss	xmm4, DWORD PTR ?CanvasPos@Mouse@Input@@2U?$vec@$02M$0A@@glm@@A+4
	movss	xmm3, DWORD PTR ?CanvasPos@Mouse@Input@@2U?$vec@$02M$0A@@glm@@A
$LN1710@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 90   : 		: x(static_cast<T>(v.x))

	movss	DWORD PTR $T309[rsp], xmm3

; 91   : 		, y(static_cast<T>(v.y))

	movss	DWORD PTR $T309[rsp+4], xmm4
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp

; 24   : 		}

	jmp	SHORT $LN2217@DrawCanvas
$LN1708@DrawCanvas:

; 25   : 		else if (Input::Mouse::State == SDL_RELEASED) {

	test	al, al
	jne	SHORT $LN1712@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\compute_vector_relational.hpp

; 15   : 			return a == b;

	movss	xmm0, DWORD PTR [rcx+96]
	ucomiss	xmm0, DWORD PTR [rcx+104]
	jp	SHORT $LN1712@DrawCanvas
	jne	SHORT $LN1712@DrawCanvas
	movss	xmm0, DWORD PTR [rcx+100]
	ucomiss	xmm0, DWORD PTR [rcx+108]
	jp	SHORT $LN1712@DrawCanvas
	jne	SHORT $LN1712@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 53   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T310[rsp], -1082130432	; bf800000H

; 54   : 		, y(static_cast<T>(_y))

	mov	DWORD PTR $T310[rsp+4], -1082130432	; bf800000H
; File H:\Downloads\Photo Studio\Photo Studio\Source\Tools\RectangularSelect.cpp

; 27   : 				m_Start = { -1,-1 };

	mov	rax, QWORD PTR $T310[rsp]
	mov	QWORD PTR [rcx+96], rax
; File H:\Downloads\Photo Studio\Photo Studio\Dependencies\glm\detail\type_vec2.inl

; 53   : 		: x(static_cast<T>(_x))

	mov	DWORD PTR $T311[rsp], -1082130432	; bf800000H

; 54   : 		, y(static_cast<T>(_y))

	mov	DWORD PTR $T311[rsp+4], -1082130432	; bf800000H
$LN2217@DrawCanvas:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1750 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

	mov	rax, QWORD PTR $T311[rsp]
	mov	QWORD PTR [rcx+104], rax
$LN1712@DrawCanvas:
	mov	rax, QWORD PTR [rsi+88]
	sub	rax, QWORD PTR [rsi+80]
	sar	rax, 4
	cmp	rax, QWORD PTR [rsi+40]
	jbe	$LN2209@DrawCanvas
; File H:\Downloads\Photo Studio\Photo Studio\Source\Framebuffer.cpp

; 53   : 	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	xor	edx, edx
	mov	ecx, 36160				; 00008d40H
	call	QWORD PTR glad_glBindFramebuffer
$LN2200@DrawCanvas:
; File H:\Downloads\Photo Studio\Photo Studio\Source\Canvas.cpp

; 232  : }

	xor	ecx, ecx
	call	QWORD PTR glad_glUseProgram
	call	?End@ImGui@@YAXXZ			; ImGui::End
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1920]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rdi, QWORD PTR [r11+72]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm14, XMMWORD PTR [r11-144]
	movaps	xmm15, XMMWORD PTR [r11-160]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN2209@DrawCanvas:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.32.31326\include\vector

; 1751 :             _Xrange();

	call	?_Xrange@?$vector@V?$shared_ptr@VLayer@@@std@@V?$allocator@V?$shared_ptr@VLayer@@@std@@@2@@std@@CAXXZ ; std::vector<std::shared_ptr<Layer>,std::allocator<std::shared_ptr<Layer> > >::_Xrange
	int	3
$LN2216@DrawCanvas:
?DrawCanvas@Canvas@@QEAAXXZ ENDP			; Canvas::DrawCanvas
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$0@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$0
	lea	rcx, QWORD PTR $T45[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$1@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$1
	lea	rcx, QWORD PTR $T67[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$2@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$2
	lea	rcx, QWORD PTR $T97[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$3@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$3
	lea	rcx, QWORD PTR $T111[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$4@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$4
	lea	rcx, QWORD PTR $T141[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$5@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$5
	lea	rcx, QWORD PTR $T163[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$6@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$6
	lea	rcx, QWORD PTR $T193[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$7@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$7
	lea	rcx, QWORD PTR $T218[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$8@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$8
	lea	rcx, QWORD PTR $T240[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$8@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T311 = 48
$T309 = 48
$T310 = 48
$T308 = 48
mousePos$315 = 48
$T304 = 48
$T24 = 64
$T20 = 72
$T22 = 80
$T26 = 88
$T111 = 96
$T193 = 128
$T270 = 160
$T34 = 192
$T2 = 204
$T35 = 216
$T58 = 228
$T131 = 240
$T130 = 252
$T154 = 264
$T208 = 276
$T207 = 288
$T231 = 300
$T254 = 320
$T177 = 384
$T81 = 448
$T45 = 512
$T67 = 544
$T97 = 576
$T141 = 608
$T163 = 640
$T218 = 672
$T240 = 704
window_class$ = 736
$T37 = 768
$T60 = 832
$T133 = 896
$T156 = 960
$T210 = 1024
$T233 = 1088
$T42 = 1152
$T43 = 1216
$T65 = 1280
$T138 = 1344
$T139 = 1408
$T161 = 1472
$T215 = 1536
$T216 = 1600
$T238 = 1664
tv8401 = 1728
WindowPos$316 = 1728
$T29 = 1728
ypos$317 = 1736
xpos$318 = 1740
__$ArrayPad$ = 1744
this$ = 1968
?dtor$9@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA PROC		; `Canvas::DrawCanvas'::`1'::dtor$9
	lea	rcx, QWORD PTR $T270[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$9@?0??DrawCanvas@Canvas@@QEAAXXZ@4HA ENDP		; `Canvas::DrawCanvas'::`1'::dtor$9
text$x	ENDS
END
